# A generic to validate data
.validate <- function(x) UseMethod(".validate")
.validate.default <- function(x) {
  stop("An object of unknown class is specified")
}

# Validate 'fmdat' object generated by reformat_data()
.validate.fmdat <- function(fmdat) {
  # Need to validate only once
  if (!is.null(fmdat[["validated"]]) && fmdat[["validated"]]) {
    return
  }

  # Check fmdat
  if (class(fmdat) != "fmdat") {
    stop("'fmdat' S3 object created by reformat_data() expected")
  }
  if (is.null(names(fmdat))
      || !all.equal(names(fmdat), c("obslabs", "ranks", "rank_idx",
                                    "na.last", "ties.method", "levels",
                                    "model_name", "validated"))) {
    stop("'fmdat' contains unexpected items")
  }

  # Check items in fmdat
  if (length(fmdat[["obslabs"]]) == 0
      || length(fmdat[["obslabs"]]) != length(fmdat[["ranks"]])
      || length(fmdat[["obslabs"]]) != length(fmdat[["rank_idx"]])) {
    stop("Items in 'fmdat' must be the same length")
  }
  if (!is.ordered(fmdat[["obslabs"]])
      || length(levels(fmdat[["obslabs"]])) != 2) {
    stop("'obslabs' in 'fmdat' must be an ordered factor with two levels")
  }
  if (!is.atomic(fmdat[["ranks"]]) || !is.numeric(fmdat[["ranks"]])) {
    stop("'ranks' in 'fmdat' must be a numeric vector")
  }
  if (!is.atomic(fmdat[["rank_idx"]]) || !is.integer(fmdat[["rank_idx"]])) {
    stop("'rank_idx' in 'fmdat' must be a vector of integer")
  }

  fmdat$validated = TRUE
  fmdat
}

# Validate 'cmats' object generated by create_confmats()
.validate.cmats <- function(cmats) {
  # Need to validate only once
  if (!is.null(cmats[["validated"]]) && cmats[["validated"]]) {
    return
  }

  # Check cmats
  if (class(cmats) != "cmats") {
    stop("'cmats' S3 object created by create_confmats() expected")
  }
  if (is.null(names(cmats))
      || (names(cmats) != c("pos_num", "neg_num", "tp", "fp", "tn", "fn",
                            "ranks", "fmdat", "validated"))) {
    stop("'cmats' contains unexpected items")
  }

  # Check items in cmats
  n <- length(cmats[["tp"]])
  if (length(cmats[["fp"]]) != n || length(cmats[["tn"]]) != n
      || length(cmats[["fn"]]) != n) {
    stop("tp, fp, tn, and fn in 'cmats' must be the same length")
  }
  stopifnot(is.atomic(cmats[["tp"]]),
            is.numeric(cmats[["tp"]]),
            cmats[["tp"]][1] == 0,
            cmats[["tp"]][n] == cmats[["pos_num"]],
            is.atomic(cmats[["fp"]]),
            is.numeric(cmats[["fp"]]),
            cmats[["fp"]][1] == 0,
            cmats[["fp"]][n] == cmats[["neg_num"]],
            is.atomic(cmats[["fn"]]),
            is.numeric(cmats[["fn"]]),
            cmats[["fn"]][1] == cmats[["pos_num"]],
            cmats[["fn"]][n] == 0,
            is.atomic(cmats[["tn"]]),
            is.numeric(cmats[["tn"]]),
            cmats[["tn"]][1] == cmats[["neg_num"]],
            cmats[["tn"]][n] == 0)

  cmats$validated = TRUE
  cmats
}

# Validate 'evals' object generated by calc_measures()
.validate.evals <- function(evals) {
  # Need to validate only once
  if (!is.null(evals[["validated"]]) && evals[["validated"]]) {
    return
  }

  # Check evals
  if (class(evals) != "evals") {
    stop("'evals' S3 object created by calc_measures() expected")
  }
  if (is.null(names(evals))
      || (names(evals) != c("pos_num", "neg_num", "error", "accuracy",
                            "specificity", "sensitivity", "precision",
                            "cmats", "validated"))) {
    stop("'evals' contains unexpected items")
  }

  # Check items in evals
  n <- length(evals[["error"]])
  if (length(evals[["accuracy"]]) != n || length(evals[["specificity"]]) != n
      || length(evals[["sensitivity"]]) != n
      || length(evals[["precision"]]) != n) {
    stop("All evaluation vectors must be the same length")
  }
  stopifnot(is.atomic(evals[["error"]]),
            is.numeric(evals[["error"]]),
            is.atomic(evals[["accuracy"]]),
            is.numeric(evals[["accuracy"]]),
            evals[["error"]][1] + evals[["accuracy"]][1] == 1,
            evals[["error"]][n] + evals[["accuracy"]][n] ==1,
            is.atomic(evals[["specificity"]]),
            is.numeric(evals[["specificity"]]),
            evals[["specificity"]][1] == 1,
            evals[["specificity"]][n] == 0,
            is.atomic(evals[["sensitivity"]]),
            is.numeric(evals[["sensitivity"]]),
            evals[["sensitivity"]][1] == 0,
            evals[["sensitivity"]][n] == 1,
            is.atomic(evals[["precision"]]),
            is.numeric(evals[["precision"]]),
            evals[["precision"]][1] == evals[["precision"]][2])

  evals$validated = TRUE
  evals
}

# Validate 'roc_curve' or 'prc_curve'
.validate_curve <- function(obj, class_name) {

  # Check items
  if (is.null(names(obj))
      || (names(obj) != c("x", "y", "orig_points", "pos_num", "neg_num",
                          "auc", "auc2", "clipped", "x_limits", "y_limits",
                          "smoothed", "smooth_method", "orig_curve",
                          "evals", "validated"))) {
    stop(paste("'", class_name ,"' contains unexpected items", sep=""))
  }

  if ((length(obj[["x"]]) != length(obj[["y"]]))
      || (length(obj[["x"]]) != length(obj[["orig_points"]]))) {
    stop("x, y, and orig_points must be the same length")
  } else if (!(length(obj[["x"]]) > 2)) {
    stop("x, y, and orig_points must be >2")
  }
  stopifnot((obj[["auc"]] >= 0) && (obj[["auc"]] <= 1),
            is.na(obj[["auc2"]])
            || (obj[["auc2"]] >= 0 && obj[["auc2"]] <= 1),
            is.atomic(obj[["clipped"]]),
            is.logical(obj[["clipped"]]),
            is.atomic(obj[["x_limits"]]),
            is.numeric(obj[["x_limits"]]),
            length(obj[["x_limits"]]) == 2,
            obj[["x_limits"]][1] >= 0 && obj[["x_limits"]][1] <= 1,
            obj[["x_limits"]][2] >= 0 && obj[["x_limits"]][2] <= 1,
            obj[["x_limits"]][1] < obj[["x_limits"]][2],
            is.atomic(obj[["y_limits"]]),
            is.numeric(obj[["y_limits"]]),
            length(obj[["y_limits"]]) == 2,
            obj[["y_limits"]][1] >= 0 && obj[["y_limits"]][1] <= 1,
            obj[["y_limits"]][2] >= 0 && obj[["y_limits"]][2] <= 1,
            obj[["y_limits"]][1] < obj[["y_limits"]][2],
            is.atomic(obj[["smoothed"]]),
            is.logical(obj[["smoothed"]]),
            is.atomic(obj[["smooth_method"]]),
            is.na(obj[["smooth_method"]])
            || is.character(obj[["smooth_method"]]),
            length(obj[["smooth_method"]]) == 1,
            is.na(obj[["orig_curve"]])
            || class(obj[["orig_curve"]]) == class_name)
}

# Validate 'roc_curve' object generated by create_roc()
.validate.roc_curve <- function(roc_curve) {
  # Need to validate only once
  if (!is.null(roc_curve[["validated"]]) && roc_curve[["validated"]]) {
    return
  }

  # Check roc_curve
  if (class(roc_curve) != "roc_curve") {
    stop("'roc_curve' S3 object created by create_roc() expected")
  }

  .validate_curve(roc_curve, "roc_curve")

  roc_curve$validated = TRUE
  roc_curve
}

# Validate 'prc_curve' object generated by create_roc()
.validate.prc_curve <- function(prc_curve) {
  # Need to validate only once
  if (!is.null(prc_curve[["validated"]]) && prc_curve[["validated"]]) {
    return
  }

  # Check prc_curve
  if (class(prc_curve) != "prc_curve") {
    stop("'prc_curve' S3 object created by create_prc() expected")
  }

  .validate_curve(prc_curve, "prc_curve")

  prc_curve$validated = TRUE
  prc_curve
}

# Validate 'curves' object generated by create_curves()
.validate.curves <- function(curves) {
  # Need to validate only once
  if (!is.null(curves[["validated"]]) && curves[["validated"]]) {
    return
  }

  # Check curves
  if (class(curves) != "curves") {
    stop("'curves' S3 object created by calc_measures() expected")
  }
  if (is.null(names(curves))
      || (names(curves) != c("roc", "prc", "validated"))) {
    stop("'curves' contains unexpected items")
  }

  # Check items in evals
  .validate(curves[["roc"]])
  .validate(curves[["prc"]])

  curves$validated = TRUE
  curves
}
